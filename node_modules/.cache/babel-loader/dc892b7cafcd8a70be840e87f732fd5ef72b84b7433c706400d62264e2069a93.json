{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapReduceOperation = void 0;\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\nconst exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation', 'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\nclass MapReduceOperation extends command_1.CommandOperation {\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(collection, map, reduce, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n    const mapCommandHash = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n    if (options.scope) {\n      mapCommandHash.scope = processScope(options.scope);\n    }\n    // Add any other options passed in\n    for (const n in options) {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = options[n];\n      }\n    }\n    options = Object.assign({}, options);\n    // If we have a read preference and inline is not set as output fail hard\n    if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {\n      // Force readPreference to primary\n      options.readPreference = read_preference_1.ReadPreference.primary;\n      // Decorate command with writeConcern if supported\n      (0, utils_1.applyWriteConcern)(mapCommandHash, {\n        db: coll.s.db,\n        collection: coll\n      }, options);\n    } else {\n      (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);\n    }\n    // Is bypassDocumentValidation specified\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    // Have we specified collation\n    try {\n      (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n    if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {\n      callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));\n      return;\n    }\n    // Execute command\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\n      if (err) return callback(err);\n      // Check if we have an error\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return callback(new error_1.MongoServerError(result));\n      }\n      // If an explain option was executed, don't process the server results\n      if (this.explain) return callback(undefined, result);\n      // Create statistics value\n      const stats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing;\n      // invoked with inline?\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(undefined, result.results);\n        }\n        return callback(undefined, {\n          results: result.results,\n          stats: stats\n        });\n      }\n      // The returned collection\n      let collection = null;\n      // If we have an object it's a different db\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result;\n        // Return a collection from another db\n        collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      }\n      // If we wish for no verbosity\n      if (options['verbose'] == null || !options['verbose']) {\n        return callback(err, collection);\n      }\n      // Return stats as third set of values\n      callback(err, {\n        collection,\n        stats\n      });\n    });\n  }\n}\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\nfunction processScope(scope) {\n  if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n  const newScope = {};\n  for (const key of Object.keys(scope)) {\n    if ('function' === typeof scope[key]) {\n      newScope[key] = new bson_1.Code(String(scope[key]));\n    } else if (scope[key]._bsontype === 'Code') {\n      newScope[key] = scope[key];\n    } else {\n      newScope[key] = processScope(scope[key]);\n    }\n  }\n  return newScope;\n}\n(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);","map":{"version":3,"mappings":"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","names":["exclusionList","MapReduceOperation","command_1","constructor","collection","map","reduce","options","execute","server","session","callback","coll","mapCommandHash","mapReduce","collectionName","scope","processScope","n","indexOf","Object","assign","readPreference","mode","read_preference_1","primary","out","inline","db","s","bypassDocumentValidation","err","explain","error_1","name","executeCommand","result","ok","errmsg","undefined","stats","timeMillis","counts","timing","results","doc","client","exports","_bsontype","newScope","key","keys","bson_1","String","operation_1","EXPLAINABLE"],"sources":["/Users/seifmohamed/Documents/webdev/node_modules/mongodb/src/operations/map_reduce.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\nimport { Code, Document } from '../bson';\nimport type { Collection } from '../collection';\nimport { MongoCompatibilityError, MongoServerError } from '../error';\nimport { ReadPreference, ReadPreferenceMode } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Sort } from '../sort';\nimport {\n  applyWriteConcern,\n  Callback,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  isObject,\n  maxWireVersion\n} from '../utils';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\nconst exclusionList = [\n  'explain',\n  'readPreference',\n  'readConcern',\n  'session',\n  'bypassDocumentValidation',\n  'writeConcern',\n  'raw',\n  'fieldsAsRaw',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bsonRegExp',\n  'serializeFunctions',\n  'ignoreUndefined',\n  'enableUtf8Validation',\n  'scope' // this option is reformatted thus exclude the original\n];\n\n/** @public */\nexport type MapFunction<TSchema = Document> = (this: TSchema) => void;\n/** @public */\nexport type ReduceFunction<TKey = ObjectId, TValue = any> = (key: TKey, values: TValue[]) => TValue;\n/** @public */\nexport type FinalizeFunction<TKey = ObjectId, TValue = Document> = (\n  key: TKey,\n  reducedValue: TValue\n) => TValue;\n\n/** @public */\nexport interface MapReduceOptions<TKey = ObjectId, TValue = Document>\n  extends CommandOperationOptions {\n  /** Sets the output target for the map reduce job. */\n  out?: 'inline' | { inline: 1 } | { replace: string } | { merge: string } | { reduce: string };\n  /** Query filter object. */\n  query?: Document;\n  /** Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces. */\n  sort?: Sort;\n  /** Number of objects to return from collection. */\n  limit?: number;\n  /** Keep temporary data. */\n  keeptemp?: boolean;\n  /** Finalize function. */\n  finalize?: FinalizeFunction<TKey, TValue> | string;\n  /** Can pass in variables that can be access from map/reduce/finalize. */\n  scope?: Document;\n  /** It is possible to make the execution stay in JS. Provided in MongoDB \\> 2.0.X. */\n  jsMode?: boolean;\n  /** Provide statistics on job execution time. */\n  verbose?: boolean;\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\n  bypassDocumentValidation?: boolean;\n}\n\ninterface MapReduceStats {\n  processtime?: number;\n  counts?: number;\n  timing?: number;\n}\n\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\nexport class MapReduceOperation extends CommandOperation<Document | Document[]> {\n  override options: MapReduceOptions;\n  collection: Collection;\n  /** The mapping function. */\n  map: MapFunction | string;\n  /** The reduce function. */\n  reduce: ReduceFunction | string;\n\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(\n    collection: Collection,\n    map: MapFunction | string,\n    reduce: ReduceFunction | string,\n    options?: MapReduceOptions\n  ) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document | Document[]>\n  ): void {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n\n    const mapCommandHash: Document = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n\n    if (options.scope) {\n      mapCommandHash.scope = processScope(options.scope);\n    }\n\n    // Add any other options passed in\n    for (const n in options) {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = (options as any)[n];\n      }\n    }\n\n    options = Object.assign({}, options);\n\n    // If we have a read preference and inline is not set as output fail hard\n    if (\n      this.readPreference.mode === ReadPreferenceMode.primary &&\n      options.out &&\n      (options.out as any).inline !== 1 &&\n      options.out !== 'inline'\n    ) {\n      // Force readPreference to primary\n      options.readPreference = ReadPreference.primary;\n      // Decorate command with writeConcern if supported\n      applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options);\n    } else {\n      decorateWithReadConcern(mapCommandHash, coll, options);\n    }\n\n    // Is bypassDocumentValidation specified\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    // Have we specified collation\n    try {\n      decorateWithCollation(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n\n    if (this.explain && maxWireVersion(server) < 9) {\n      callback(\n        new MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`)\n      );\n      return;\n    }\n\n    // Execute command\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\n      if (err) return callback(err);\n      // Check if we have an error\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return callback(new MongoServerError(result));\n      }\n\n      // If an explain option was executed, don't process the server results\n      if (this.explain) return callback(undefined, result);\n\n      // Create statistics value\n      const stats: MapReduceStats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing;\n\n      // invoked with inline?\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(undefined, result.results);\n        }\n\n        return callback(undefined, { results: result.results, stats: stats });\n      }\n\n      // The returned collection\n      let collection = null;\n\n      // If we have an object it's a different db\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result;\n        // Return a collection from another db\n        collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      }\n\n      // If we wish for no verbosity\n      if (options['verbose'] == null || !options['verbose']) {\n        return callback(err, collection);\n      }\n\n      // Return stats as third set of values\n      callback(err, { collection, stats });\n    });\n  }\n}\n\n/** Functions that are passed as scope args must be converted to Code instances. */\nfunction processScope(scope: Document | ObjectId) {\n  if (!isObject(scope) || (scope as any)._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  const newScope: Document = {};\n\n  for (const key of Object.keys(scope)) {\n    if ('function' === typeof (scope as Document)[key]) {\n      newScope[key] = new Code(String((scope as Document)[key]));\n    } else if ((scope as Document)[key]._bsontype === 'Code') {\n      newScope[key] = (scope as Document)[key];\n    } else {\n      newScope[key] = processScope((scope as Document)[key]);\n    }\n  }\n\n  return newScope;\n}\n\ndefineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}